 /** 
   @file  tpp_impl.cpp 
   @brief The implementation of the Delaunay class and iterators of the Triangle++ wrapper

   The Delaunay class and iterators are a wrapper on the J.R. Shevchuk's Triangle package (aka TriLib).

   @author  Marek Krajewski (mrkkrj), www.ib-krajewski.de 
   @author  + others!!! (@see tpp_interface.hpp)
 */


// configuaration of the Triangle.h (i.e. TriLib's code):
#define NO_TIMER
#define DREDUCED
#define ANSI_DECLARATORS
#define TRILIBRARY
#define TRILIB_EXIT_BY_EXCEPTION
#define TRIFILES_OUTPUT_SUPPORT
#define TRIFILES_READ_SUPPORT
//#define CDT_ONLY // no, we want all algorithms!

#ifndef _WIN64
// the MS x64 compilers do not use FPU (as SSE is the default) thus no extended precision problems!
#  define CPU86
#endif

#ifndef _WIN32
#define LINUX
#undef CPU86
#endif

// trace support:
//#define TRIANGLE_DBG_TO_FILE 1

#include "tpp_trace.hpp"

// 1. wrapped library (TriLib)
#include "triangle_impl.hpp"

// 2. the wrapper itself (TrianglePP)
#include "tpp_interface.hpp"

#include <iostream>
#include <sstream>
#include <algorithm>


// helper macros
#define TP_MESH_BEHAVIOR() \
    Triwrap::__pmesh* tpmesh = static_cast<Triwrap::__pmesh *>(m_pmesh); \
    Triwrap::__pbehavior* tpbehavior = static_cast<Triwrap::__pbehavior *>(m_pbehavior);

#define TP_MESH() \
    Triwrap::__pmesh* tpmesh = static_cast<Triwrap::__pmesh *>(m_pmesh);

#define TP_MESH_PTR() \
    static_cast<Triwrap::__pmesh *>(m_pmesh)

#define TP_MESH_BEHAVIOR_WRAP() \
    Triwrap::__pmesh* tpmesh = static_cast<Triwrap::__pmesh *>(m_pmesh); \
    Triwrap::__pbehavior* tpbehavior = static_cast<Triwrap::__pbehavior *>(m_pbehavior); \
    Triwrap* pTriangleWrap = static_cast<Triwrap *>(m_triangleWrap);

#define TP_WRAP_PTR() \
    static_cast<Triwrap *>(m_triangleWrap);

#define TP_VOROUT() \
    triangulateio* tpvorout = static_cast<triangulateio*>(m_vorout);

#define TP_PLOOP_PTR(fit) ((Triwrap::__otriangle *)(&(fit.floop)))

#define TP_MESH_PLOOP(fit) \
     Triwrap::__pmesh  * tpmesh  = (Triwrap::__pmesh *) (fit.m_delaunay->m_pmesh); \
     Triwrap::__otriangle* ploop = (Triwrap::__otriangle*)(&(fit.floop));


// custom specialization of std::hash for Delaunay::Points
namespace std 
{
    template <>
    struct hash<tpp::Delaunay::Point>
    {
        std::size_t operator()(const tpp::Delaunay::Point& p) const
        {
            std::size_t h1 = std::hash<double>{}(p[0]);
            std::size_t h2 = std::hash<double>{}(p[1]);
            return h1 ^ (h2 << 1); // combine hashes
        }
    };
}


namespace tpp {

   // trace support
   FILE* g_debugFile = nullptr;

   // impl. constant
   const char* trppFileComment =  "\n# Generated by Triangle++" ;


// public methods

Delaunay::Delaunay(const std::vector<Point>& points, bool enableMeshIndexing)
   : m_triangleWrap(nullptr),
     m_in(nullptr),
     m_pmesh(nullptr),
     m_pbehavior(nullptr),
     m_vorout(nullptr),
     m_minAngle(0.0f),
     m_maxArea(0.0f),
     m_convexHullWithSegments(false),
     m_extraVertexAttr(enableMeshIndexing),
     m_triangulated(false)
{
   m_pointList.assign(points.begin(), points.end());
}


Delaunay::~Delaunay()
{
   freeTriangleDataStructs();
}


void Delaunay::Triangulate(bool quality, DebugOutputLevel traceLvl)
{
   std::string options = "nz";  // n: need neighbors, z: index from 0

   setQualityOptions(options, quality);
   setDebugLevelOption(options, traceLvl);

   triangulateTriLib(options);
}


void Delaunay::TriangulateConf(bool quality, DebugOutputLevel traceLvl)
{
   std::string options = "nz";  // n: need neighbors, z: index from 0

   setQualityOptions(options, quality);
   options.append("D"); // conforming Delaunay!
   setDebugLevelOption(options, traceLvl);

   triangulateTriLib(options);
}


void Delaunay::Tesselate(bool useConformingDelaunay, DebugOutputLevel traceLvl) 
{
   std::string options = "nz";  // n: need neighbors, z: index from 0
   setDebugLevelOption(options, traceLvl);

   // "If the triangulated domain is"
   //"  convex and has no holes, you can use -D switch to force Triangle to"
   //"  construct a conforming Delaunay triangulation instead of a CCDT, so the"
   //"  Voronoi diagram will be valid."

   //options.append("D"); // Voronoi precondition ??? not really!!!

   if (useConformingDelaunay)
   {
      options.append("D");
   }
   options.append("v"); // Voronoi

   triangulateTriLib(options);

   // now use the triangulation for a Voronoi diagram
   TP_MESH_BEHAVIOR_WRAP();

   // OPEN TODO::: check those preconditions??
   if (tpmesh->holes != 0)
   {
       /* ............ */
   }

   m_vorout = new triangulateio;
   TP_VOROUT();

   tpvorout->numberofpoints = tpmesh->triangles.items;
   tpvorout->numberofpointattributes = tpmesh->nextras;
   tpvorout->numberofedges = tpmesh->edges;

   tpvorout->pointlist = nullptr;
   tpvorout->pointattributelist = nullptr;
   tpvorout->pointmarkerlist = nullptr;
   tpvorout->numberofsegments = 0;
   tpvorout->numberofholes = 0;
   tpvorout->numberofregions = 0;
   tpvorout->regionlist = nullptr;
   tpvorout->edgelist = nullptr;
   tpvorout->edgemarkerlist = nullptr;
   tpvorout->normlist = nullptr;

   pTriangleWrap->writevoronoi(
         tpmesh, tpbehavior,
         &tpvorout->pointlist, &tpvorout->pointattributelist,
         &tpvorout->pointmarkerlist, &tpvorout->edgelist,
         &tpvorout->edgemarkerlist, &tpvorout->normlist);
}


bool Delaunay::checkConstraints(bool& possible) const
{
   //"     If the minimum angle is 28.6"
   //"        degrees or smaller, Triangle is mathematically guaranteed to"
   //"        terminate (assuming infinite precision arithmetic--Triangle may"
   //"        fail to terminate if you run out of precision).  In practice,"
   //"        Triangle often succeeds for minimum angles up to 34 degrees.  For"
   //"        some meshes, however, you might need to reduce the minimum angle to"
   //"        avoid problems associated with insufficient floating-point"
   //"        precision."
   if (m_minAngle <= 28.6f)
   {
      return true;
   }
   else
   {
      possible = (m_minAngle <= 34.0f);
      return false;
   }   
}


bool Delaunay::checkConstraintsOpt(bool relaxed) const
{
   bool possible = false;
   bool ret = checkConstraints(possible);

   if (!ret && relaxed)
   {
      return possible;
   }
   else
   {
      return ret;
   }
}


void Delaunay::getMinAngleBoundaries(float& guaranteed, float& possible)
{
   // see above:
   guaranteed = 28.6f;
   possible = 34.0f;
}


void Delaunay::setQualityConstraints(float angle, float area)
{
   setMinAngle(angle);
   setMaxArea(area);
}


bool Delaunay::setSegmentConstraint(const std::vector<Point>& segments)
{
   m_segmentList.clear();
   m_segmentList.reserve(segments.size());

   // OPEN TODO::: optimize - unquadrat it...
   for (int i = 0; i < segments.size(); ++i)
   {
      const std::vector<Point>::iterator it = std::find(m_pointList.begin(), m_pointList.end(), segments[i]);
      if (it == m_pointList.end())
      {
         m_segmentList.clear();
         return false;
      }
      else
      {
         m_segmentList.push_back(std::distance(m_pointList.begin(), it));
      }
   }

   // OPEN TODO::: check for intersections ???
   //  - seems to be not needed, re-read what the documentiation of Trilibrary says!!!!

   // OPEN TODO:::   sanitize inputs!!!!
   //  -- needed??? --> First of the points will be found when determining the point index

   return true;
}


bool Delaunay::setSegmentConstraint(const std::vector<int>& segmentPointIndexes, DebugOutputLevel traceLvl)
{
   m_segmentList.clear();
   m_segmentList.reserve(segmentPointIndexes.size());

   for (int i = 0; i < segmentPointIndexes.size(); ++i)
   {      
      const int& pointIdx = segmentPointIndexes[i];
      if (pointIdx < 0 ||
          pointIdx >= m_pointList.size())
      {
         m_segmentList.clear();
         return false;
      }
      else
      {
         m_segmentList.push_back(pointIdx);
      }
   }

   // OPEN TODO::: check for intersections ???
   //  - seems to be not needed (???), re-read what the documentiation of Trilibrary says!!!!

   // sanitize inputs
   std::unordered_map<int, int> duplicates = checkForDuplicatePoints();

   if (!duplicates.empty())
   {
       sanitizeInputData(duplicates, traceLvl);
   }

   return true;
}


void Delaunay::enableMeshIndexGeneration() 
{
   m_extraVertexAttr = true;
}


void Delaunay::useConvexHullWithSegments(bool useConvexHull)
{
#if 0
    // --> Yejneshwar commented on 26 Feb 22
    //Hi,
    //    Thank you for this implementation.
    //    could you please add support for the D tag ?
    //    i.e.remove concavities
    //
    //    EDIT :
    //    I have fixed the issue, will be submitting a pull request soon.
    //    Support for it existed but internally the "c" tag would still be added which caused the concavities to not be removed.

    TriangulateConf(options); //created a new function just for the -D tag, because the -c tag doesn't remove concavities with a boundary defined through the segment list.
#endif

    m_convexHullWithSegments = useConvexHull; // with/without convex hull (credits Yejneshwar!)
}


bool Delaunay::setHolesConstraint(const std::vector<Point>& holes)
{
   m_holesList = holes;

   // OPEN TODO::: check the intersection constraints ... ???

   return true;
}


void Delaunay::writeoff(std::string& fname)
{
    if(!m_triangulated)
    {
        std::cerr << "ERROR: Write called before triangulation!\n";
        throw std::runtime_error("Write called before triangulation");
    }

    TP_MESH_BEHAVIOR_WRAP();

    char *pfname = new char[fname.size()+1];
    strcpy(pfname , fname.c_str());

    pTriangleWrap->writeoff(tpmesh, tpbehavior, pfname, 0, nullptr);
    delete [] pfname;
}


bool Delaunay::savePoints(const std::string& filePath)
{          
   if (!m_triangulated) 
   {
     struct triangulateio input;
     triangulateio* pin = (struct triangulateio *)&input;
    
     initTriangleInputData(pin, m_pointList);

     if (!m_triangleWrap)
     {
        Assert(!m_pmesh && !m_pbehavior, "");
        initTriangleDataForPoints();
     }

     TP_MESH_BEHAVIOR_WRAP();

     pTriangleWrap->transfernodes(
                tpmesh, tpbehavior, pin->pointlist, 
                pin->pointattributelist,
                pin->pointmarkerlist, pin->numberofpoints,
                pin->numberofpointattributes);
   }

   TP_MESH_BEHAVIOR_WRAP();
   const char* comments[] = { trppFileComment };
       
   pTriangleWrap->writenodes2file(tpmesh, tpbehavior, const_cast<char*>(filePath.c_str()),
                                  sizeof(comments)/sizeof(const char*), const_cast<char**>(comments));
   return true;
}


bool Delaunay::saveSegments(const std::string& filePath)
{
   if (!m_triangulated) 
   {
       // TEST:: disable carving of holes!
       //TP_BEHAVIOR_PTR()->refine = 1;
       // TEST:::
       //m_convexHullWithSegments = true; ??????

       Triangulate();
   }

   TP_MESH_BEHAVIOR_WRAP();

   // first write nodes
   char* polyfileName = const_cast<char*>(filePath.c_str());
   pTriangleWrap->writenodes2file(tpmesh, tpbehavior, polyfileName, 0, nullptr);

   // OPEN TODO:::: regions support???
   int numberofregions = 0;
   double* regionlist = nullptr;

   // holes?
   int numberofholes = 0;
   double* holelist = nullptr;

   if (!m_holesList.empty())
   {
       numberofholes = (int)m_holesList.size();
       holelist = static_cast<double*>((void*)(&m_holesList[0]));
   }

    bool append = true; // write into a single file!
    const char* comments[] = { trppFileComment };

    pTriangleWrap->writepoly2file(tpmesh, tpbehavior, polyfileName,
                                  holelist, numberofholes, regionlist, numberofregions,
                                  append,
                                  sizeof(comments)/sizeof(const char*), const_cast<char**>(comments));

    return true;
}


bool Delaunay::readPoints(const std::string& filePath, std::vector<Delaunay::Point>& points)
{  
    if (!m_triangleWrap)
    {
       Assert(!m_pmesh && !m_pbehavior, "");
       initTriangleDataForPoints();
    }

    TP_MESH_BEHAVIOR_WRAP();

    tpbehavior->poly = 0; // poly file not provided!
    tpbehavior->usesegments = 0;
    FILE* polyfile = nullptr;
    char* polyfileName = nullptr; // no poly file!

    pTriangleWrap->readnodes(tpmesh, tpbehavior, const_cast<char*>(filePath.c_str()), polyfileName, &polyfile);

    // read points from the mesh data
    readPointsFromMesh(m_pointList);
       
    points = m_pointList; // OPEN TODO::: make optional parameter?????
    return true;
}


bool Delaunay::readSegments(
        const std::string& filePath,
        std::vector<Delaunay::Point>& points,
        std::vector<int>& segmentEndpoints,
        std::vector<Delaunay::Point>& holeMarkers)
{
    if (!m_triangleWrap)
    {
       Assert(!m_pmesh && !m_pbehavior, "");
       initTriangleDataForPoints();
    }

    TP_MESH_BEHAVIOR_WRAP();

    tpbehavior->poly = 1; // poly file provided!
    tpbehavior->usesegments = 1;   

    tpmesh->steinerleft = tpbehavior->steiner;

    FILE* polyfile = nullptr;
    char* polyfileName = const_cast<char*>(filePath.c_str());
    pTriangleWrap->readnodes(tpmesh, tpbehavior, nullptr, polyfileName, &polyfile);

    // get points from the mesh data
    readPointsFromMesh(m_pointList);
    points = m_pointList; // OPEN TODO::: make it optional param????

    auto duplicates = checkForDuplicatePoints();
    if (!duplicates.empty())
    {
        // read file directly
        //  - Trilib's code doesn't support duplicate points!
        if (!readSegmentsFromFile(polyfileName, polyfile))
        {
            fclose(polyfile);
            return false;
        }

        // rebase to start with 0
        if (tpbehavior->firstnumber != 0)
        {
            for (auto& index : m_segmentList)
            {
                index -= tpbehavior->firstnumber;
                Assert(index >= 0, "");
            }
        }

        sanitizeInputData(duplicates); 

        points = m_pointList; // OPEN TODO::: make it optional param????
        segmentEndpoints = m_segmentList; // OPEN TODO::: make it optional param????
    }
    else
    {
        // triangulate to ensure formskeleton() will read segments!
        tpmesh->hullsize = pTriangleWrap->delaunay(tpmesh, tpbehavior);

        // Ensure that no vertex can be mistaken for a triangular bounding box
        // vertex in insertvertex()!
        tpmesh->infvertex1 = nullptr;
        tpmesh->infvertex2 = nullptr;
        tpmesh->infvertex3 = nullptr;

        tpmesh->checksegments = 1;

        // no holes yet:
        tpmesh->holes = 0;
        tpmesh->regions = 0;

        pTriangleWrap->formskeleton4file(tpmesh, tpbehavior, polyfile, polyfileName);

        // get segments from the mesh data
        readSegmentsFromMesh(m_segmentList);

        // rebase to start with 0
        if (tpbehavior->firstnumber != 0)
        {
            for (auto& index : m_segmentList)
            {
                index -= tpbehavior->firstnumber;
            }
        }

        segmentEndpoints = m_segmentList; // OPEN TODO::: make it optional param????
    }

    // get hole marker points
    REAL *holearray = nullptr;
    REAL *regionarray = nullptr;
    m_holesList.clear();

    pTriangleWrap->readholes(tpmesh, tpbehavior, polyfile, polyfileName,
                             &holearray, &tpmesh->holes, &regionarray, &tpmesh->regions);

    for (int i = 0; i < 2 * tpmesh->holes; i += 2)
    {
        m_holesList.emplace_back(holearray[i], holearray[i + 1]);
    }

    holeMarkers = m_holesList; // OPEN TODO::: make it optional param????

    if (tpmesh->holes > 0)
    {
      pTriangleWrap->trifree((VOID *) holearray);
    }

    // regions not yet supported!
    if (tpmesh->regions > 0)
    {
      pTriangleWrap->trifree((VOID *) regionarray);
    }

    // ready
    fclose(polyfile);
    return true;
}


int Delaunay::edgeCount() const
{
    return TP_MESH_PTR()->edges;
}


int Delaunay::triangleCount() const
{
    return TP_MESH_PTR()->triangles.items;
}


int Delaunay::verticeCount() const
{
    TP_MESH_BEHAVIOR();
    int outvertices;

    if (tpbehavior->jettison) 
    {
        outvertices = tpmesh->vertices.items - tpmesh->undeads;
    } 
    else 
    {
        outvertices = tpmesh->vertices.items;
    }

    return outvertices;
}


int Delaunay::hullSize() const
{
   return TP_MESH_PTR()->hullsize;
}


#ifdef TRPP_OLD_NAMES_SUPPORTED
int Delaunay::nedges() const
{
   return edgeCount();
}
int Delaunay::ntriangles() const
{
   return triangleCount();
}
int Delaunay::nvertices() const
{
   return verticeCount();
}
int Delaunay::hull_size() const
{
   return hullSize();
}
int Delaunay::nvedges() const
{
   return voronoiEdgeCount();
}
int Delaunay::nvpoints() const
{
   return voronoiPointCount();
}
int Delaunay::nholes() const
{
   return holeCount();
}
#endif // TRPP_OLD_NAMES_SUPPORTED


int Delaunay::voronoiEdgeCount() const
{
   TP_VOROUT();

   if (!tpvorout)
   {
      return 0;
   }
   else
   {
      return tpvorout->numberofedges;
   }
}


int Delaunay::voronoiPointCount() const
{
   TP_VOROUT();

   if (!tpvorout)
   {
      return 0;
   }
   else
   {
      return tpvorout->numberofpoints;
   }
}


int Delaunay::holeCount() const
{
    return TP_MESH_PTR()->holes;
}


bool Delaunay::hasTriangulation() const
{
    return m_triangulated;
}


fIterator Delaunay::fbegin()
{
   return fIterator(this);
}


fIterator Delaunay::fend()
{
   fIterator fit;
   fit.floop.tri = (double***) nullptr;
   return fit;
}


FacesList Delaunay::faces()
{ 
   return FacesList(this);
};


fIterator FacesList::begin()
{
   return m_delaunay->fbegin();
}


fIterator FacesList::end()
{
   return m_delaunay->fend();
}


vIterator Delaunay::vbegin()
{
   return vIterator(this);
}


vIterator Delaunay::vend()
{
   vIterator vit;
   vit.vloop = ((Triwrap::vertex) nullptr);
   return vit;
}


vvIterator Delaunay::vvbegin()
{
   return vvIterator(this);
}


vvIterator Delaunay::vvend()
{
   vvIterator vvit;
   vvit.vvloop = nullptr;
   vvit.vvindex = 0;
   vvit.vvcount = 0;
   vvit.m_delaunay = nullptr;

   return vvit;
}


veIterator Delaunay::vebegin()
{
   return veIterator(this);
}


veIterator Delaunay::veend()
{
   veIterator veit;
   veit.veloop = nullptr;
   veit.veindex = 0;
   veit.vecount = 0;
   veit.m_delaunay = nullptr;

   return veit;
}


void Delaunay::getMinMaxPoints(double& minX, double& minY, double& maxX, double& maxY) const
{
    TP_MESH();

    minX = tpmesh->xmin;
    minY = tpmesh->ymin;
    maxX = tpmesh->xmax;
    maxY = tpmesh->ymax;
}


const Delaunay::Point& Delaunay::pointAtVertexId(int i) const
{
    Assert(i >= 0 || i < m_pointList.size(), "Point index out of bounds!\n");

    return m_pointList[i];
}


double Delaunay::area(fIterator const& fit)
{
   Point torg, tdest, tapex;
   torg = pointAtVertexId(Org(fit));
   tdest = pointAtVertexId(Dest(fit));
   tapex = pointAtVertexId(Apex(fit));
   double dxod(torg[0] - tdest[0]);
   double dyod(torg[1] - tdest[1]);
   double dxda(tdest[0] - tapex[0]);
   double dyda(tdest[1] - tapex[1]);

   double area = 0.5 * (dxod * dyda - dyod * dxda);
   return area;
}


TriangulationMesh Delaunay::mesh()
{
   return TriangulationMesh(this);
}


bool Delaunay::OrderPoints::operator() (const Point& lhs, const Point& rhs) const
{
   // first sort on X coordinates, then on Y coordinates
   if (lhs[0] < rhs[0])
   {
      return true;
   }

   if (lhs[0] == rhs[0] && lhs[1] < rhs[1])
   {
      return true;
   }

   return false;
}


// private methods

void Delaunay::triangulateTriLib(std::string& triswitches)
{
   INIT_TRACE("triangle.out.txt");
   TRACE("Triangulate ->");

   if (m_triangulated)
   {
      freeTriangleDataStructs();
   }

   m_in = new triangulateio;
   triangulateio* pin = (struct triangulateio*)m_in;

   initTriangleInputData(pin, m_pointList);

   if (!m_segmentList.empty()) // OPEN:: a separate option to enable segment constraitns???
   {
      pin->numberofsegments = (int)m_segmentList.size() / 2;
      pin->segmentlist = m_segmentList.data();
      pin->segmentmarkerlist = nullptr;

      triswitches.append("p"); // constrained Delaunay (Planar Straight Line Graph)
      triswitches.append("B"); // but no boundary info at the moment!

      if (m_convexHullWithSegments)
      {
         triswitches.append("c"); // -c Encloses the convex hull with segments - (preserve boudnaries in carveholes())  
                                  //   --> Note: refining not supported yet!
                                  // If you are refining a mesh, this switch works differently; it generates the set of
                                  // boundary edges of the mesh, including boundaries of holes. 
      }
   }

   if (!m_holesList.empty())
   {
      pin->numberofholes = (int)m_holesList.size();
      pin->holelist = static_cast<double*>((void*)(&m_holesList[0]));

      if (m_segmentList.empty())
      {
         triswitches.append("p"); // constrained Delaunay (Planar Straight Line Graph)
         triswitches.append("B"); // but no boundary info at the moment!

         if (m_convexHullWithSegments)
         {
            triswitches.append("c"); // -c Encloses the convex hull with segments - (preserve boundaries in carveholes())
         }
      }
   }

   TRACE2s(" -- switches:", triswitches.c_str());

   // parse the options:
   triswitches.push_back('\0');
   char* pTriswitches = &triswitches[0];

   m_pmesh = new Triwrap::__pmesh;
   m_pbehavior = new Triwrap::__pbehavior;
   m_triangleWrap = new Triwrap;

   TP_MESH_BEHAVIOR_WRAP();

   pTriangleWrap->parsecommandline(1, &pTriswitches, tpbehavior);

   // initialize data structs
   pTriangleWrap->triangleinit(tpmesh);
   tpmesh->steinerleft = tpbehavior->steiner;

   pTriangleWrap->transfernodes(
      tpmesh, tpbehavior, pin->pointlist,
      pin->pointattributelist,
      pin->pointmarkerlist, pin->numberofpoints,
      pin->numberofpointattributes);

   // MAIN work: triangulate!
   tpmesh->hullsize = pTriangleWrap->delaunay(tpmesh, tpbehavior);

   // OPEN TODO:: 
   //    if(concave hull) - compute concave hull with the chi-algorithm,
   //                     - use it as segments in formskeleton()!!

   // Ensure that no vertex can be mistaken for a triangular bounding box 
   // vertex in insertvertex()!
   tpmesh->infvertex1 = nullptr;
   tpmesh->infvertex2 = nullptr;
   tpmesh->infvertex3 = nullptr;

   // support for the "-q" option
   if (tpbehavior->usesegments && (tpmesh->triangles.items > 0))
   {
      tpmesh->checksegments = 1;

      if (!tpbehavior->refine)
      {
         // Insert PSLG segments and/or convex hull segments.
         pTriangleWrap->formskeleton(tpmesh, tpbehavior, pin->segmentlist,
            pin->segmentmarkerlist, pin->numberofsegments);
      }
   }

   if (tpbehavior->quality && (tpmesh->triangles.items > 0))
   {
      // Enforce angle and area constraints
      pTriangleWrap->enforcequality(tpmesh, tpbehavior);
   }

   if (tpbehavior->poly && (tpmesh->triangles.items > 0))
   {
      tpmesh->holes = pin->numberofholes;
      double* holelist = pin->holelist;

      tpmesh->regions = 0;
      double* regionlist = nullptr; // not yet supported

      if (!tpbehavior->refine)
      {
         // Carve out holes and concavities.
         pTriangleWrap->carveholes(tpmesh, tpbehavior, holelist, tpmesh->holes, regionlist, tpmesh->regions);
      }
   }

   // Calculate the number of edges.
   tpmesh->edges = (3l * tpmesh->triangles.items + tpmesh->hullsize) / 2l;

   pTriangleWrap->numbernodes(tpmesh, tpbehavior);
   TRACE2i("<- Triangulate: triangles= ", tpmesh->triangles.items);

   m_triangulated = true;
   END_TRACE();
}


void Delaunay::setDebugLevelOption(std::string& options, DebugOutputLevel traceLvl)
{
   switch (traceLvl)
   {
   case None:
      options.append("Q"); // Q: no trace, no debug
      break;
   case Info:
      options.append("V"); // basic trace & debug
      break;
   case Vertex:
      options.append("VV"); // detailed trace & debug
      break;
   case Debug:
      options.append("VVVV"); // much, much more - too much?
      break;
   default:
       Assert(false, "unknown trace level");
   }
}


void Delaunay::setQualityOptions(std::string& options, bool quality)
{
    if (quality)
    {
        options.append("q");

        if (m_minAngle > 0)
        {
            options.append(formatFloatConstraint(m_minAngle));
        }

        if (m_maxArea > 0)
        {
            options.append("a" + formatFloatConstraint(m_maxArea));
        }
    }
}


void Delaunay::freeTriangleDataStructs()
{
   if (m_in == nullptr && m_vorout == nullptr && 
       m_triangleWrap == nullptr && m_pmesh == nullptr &&
       m_pbehavior == nullptr)
   {
      return; // already freed!
   }

   struct triangulateio* pin = (struct triangulateio*) m_in;

   TP_MESH_BEHAVIOR_WRAP();
   TP_VOROUT();

   pTriangleWrap->triangledeinit(tpmesh, tpbehavior);

   delete tpmesh;
   delete tpbehavior;
   delete pin;
   delete tpvorout;
   delete pTriangleWrap;

   m_in = nullptr;
   m_vorout = nullptr;
   m_triangleWrap = nullptr;
   m_pmesh = nullptr;
   m_pbehavior = nullptr;
}


void Delaunay::initTriangleDataForPoints()
{
    Assert(!m_triangleWrap && !m_pmesh && !m_pbehavior, "Expected empty instance!\n");

    m_triangleWrap = new Triwrap;
    m_pmesh = new Triwrap::__pmesh;
    m_pbehavior = new Triwrap::__pbehavior;

    TP_MESH_BEHAVIOR_WRAP();

    *tpmesh = {};  // OPEN TODO::: .............. {} too big for the stack, warning by VisualStudio!
    *tpbehavior = {};

    // nonzero defaults:
    tpbehavior->firstnumber = 1;
    tpbehavior->dwyer = 1;
    tpbehavior->steiner = -1;
    tpbehavior->order = 1;
    tpbehavior->maxarea = -1.0;
    tpbehavior->quiet = 1;

    pTriangleWrap->triangleinit(tpmesh);
}


void Delaunay::initTriangleInputData(triangulateio* pin, const std::vector<Point>& points) /*const*/
{
    pin->numberofpoints = (int)points.size();
    pin->numberofpointattributes = m_extraVertexAttr ? 1 : 0;
    pin->pointlist = static_cast<double*>((void*)(&points[0]));

    if (m_extraVertexAttr)
    {       
       m_defaultExtraAttrs.clear();
       m_defaultExtraAttrs.insert(m_defaultExtraAttrs.begin(), points.size(), -1.0);

       pin->pointattributelist = static_cast<double*>((void*)(&m_defaultExtraAttrs[0]));
    }
    else
    {
       pin->pointattributelist = nullptr;
    }
    
    pin->pointmarkerlist = nullptr;
    pin->numberofsegments = 0;
    pin->numberofholes = 0;
    pin->numberofregions = 0;
    pin->regionlist = nullptr;
}


void Delaunay::sanitizeInputData(std::unordered_map<int, int> duplicatePointsMap, DebugOutputLevel traceLvl)
{
    // don't use duplicated points in segments
    //  - replace with "originals"
    for (size_t i = 0; i < m_segmentList.size(); ++i)
    {
        auto& pointIdx = m_segmentList[i];
        auto iter = duplicatePointsMap.find(pointIdx);

        if (iter != duplicatePointsMap.end())
        {
            TRACE2i(" -- sanitize: duplicate point as segment endpoint detected, index=", pointIdx);
            TRACE2i(" --           replaced with index=", iter->second);

            if (traceLvl != None)
            {
                printf("Warning:  segments[%d] - a duplicate vertex (index=%d) replaced by original (index=%d).\n",
                    i / 2, pointIdx, iter->second);
            }

            pointIdx = iter->second;
        }
    }

    // remove point duplicates
    std::vector<int> duplicatePts(duplicatePointsMap.size());
    std::transform(duplicatePointsMap.begin(), duplicatePointsMap.end(), duplicatePts.begin(), [](auto& pair) { return pair.first; });
    std::sort(duplicatePts.begin(), duplicatePts.end());

    for (auto iter = duplicatePts.rbegin(); iter != duplicatePts.rend(); ++iter)
    {
        m_pointList.erase(m_pointList.begin() + *iter);

        if (traceLvl != None)
        {
            printf("Warning:  A duplicate vertex point deleted at index=%d.\n", *iter);
        }
    }

    // corrections for removed points
    for (auto& pointIdx : m_segmentList)
    {
        int i = 0;
        for (auto iter = duplicatePts.rbegin(); iter != duplicatePts.rend(); ++iter, ++i)
        {
            if (pointIdx > *iter)
            {
                if (traceLvl != None)
                {
                    printf("Warning:  Correction for segment endpoint - iter=%d pointIdx=%d, new_pointIdx=%d.\n",
                        *iter, pointIdx, pointIdx - (duplicatePts.size() - i));
                }

                pointIdx -= (duplicatePts.size() - i);
                break;
            }
        }
    }
}


void Delaunay::readPointsFromMesh(std::vector<Point>& points) const
{
    TP_MESH_BEHAVIOR_WRAP();

    points.clear();
    points.reserve(tpmesh->invertices);

    int vertexnumber = tpbehavior->firstnumber;
    Triwrap::__pmesh* m = tpmesh; // needed for Triwrap's macros vertextype()/setvertexmark()

    pTriangleWrap->traversalinit(&tpmesh->vertices);
    Triwrap::vertex vertexloop = pTriangleWrap->vertextraverse(tpmesh);

    while (vertexloop != nullptr)
    {
        if (!tpbehavior->jettison || (vertextype(vertexloop) != UNDEADVERTEX))
        {
            /* X and Y coordinates. */
            points.push_back({ vertexloop[0], vertexloop[1] });

#if 0 // --> not yet supported!
            /* Vertex attributes. */
            for (i = 0; i < tpmesh->nextras; i++) {
                palist[attribindex++] = vertexloop[2 + i];
            }
            if (!tpbehavior->nobound) {
                /* Copy the boundary marker. */
                pmlist[vertexnumber - tpbehavior->firstnumber] = vertexmark(vertexloop);
            }
#endif

            setvertexmark(vertexloop, vertexnumber);
            vertexnumber++;
        }

        vertexloop = pTriangleWrap->vertextraverse(tpmesh);
    }
}


void Delaunay::readSegmentsFromMesh(std::vector<int>& segments) const
{
    TP_MESH_BEHAVIOR_WRAP();

    segments.clear();
    segments.reserve(tpmesh->insegments);

    struct Triwrap::osub subsegloop;
    Triwrap::vertex endpoint1, endpoint2;
    long subsegnumber;

    pTriangleWrap->traversalinit(&tpmesh->subsegs);
    subsegloop.ss = pTriangleWrap->subsegtraverse(tpmesh);
    subsegloop.ssorient = 0;
    subsegnumber = tpbehavior->firstnumber;

    Triwrap::__pmesh* m = tpmesh;   // needed for Triwrap's macro vertexmark()
    typedef Triwrap::vertex vertex; // same!

    while (subsegloop.ss != nullptr)
    {
        sorg(subsegloop, endpoint1);
        sdest(subsegloop, endpoint2);

        /* Copy indices of the segment's two endpoints. */
        segments.push_back(vertexmark(endpoint1));
        segments.push_back(vertexmark(endpoint2));

#if 0 // --> not yet supported!
        if (!b->nobound) {
            /* Copy the boundary marker. */
            smlist[subsegnumber - b->firstnumber] = mark(subsegloop);
        }
#endif

        subsegloop.ss = pTriangleWrap->subsegtraverse(tpmesh);
        subsegnumber++;
    }
}


std::string Delaunay::formatFloatConstraint(float f) const
{
   std::ostringstream ss;
   ss << f;
   return ss.str();
}


std::unordered_map<int, int> Delaunay::checkForDuplicatePoints() const
{
    std::unordered_map<Delaunay::Point, size_t> uniqueMap;
    std::unordered_map<int, int> duplicateMap;

    std::equal_to<tpp::Delaunay::Point> eq;


    for (size_t i = 0; i < m_pointList.size(); ++i)
    {
        auto& point = m_pointList[i];

        auto iter = uniqueMap.find(point);
        if (iter == uniqueMap.end())
        {
            uniqueMap.insert({ point, i });
        }
        else
        {
            duplicateMap.insert({ i, iter->second });
        }
    }

    return duplicateMap;    
}


bool Delaunay::readSegmentsFromFile(char* polyfileName, FILE* polyfile)
{
    char inputline[INPUTLINESIZE];
    char* stringptr;
    Triwrap::vertex endpoint1, endpoint2;
    int segmentmarkers;
    int end1, end2;
    int boundmarker;
    int i;

    TP_MESH_BEHAVIOR_WRAP();

    stringptr = pTriangleWrap->readline(inputline, polyfile, polyfileName);
    int insegments = (int)strtol(stringptr, &stringptr, 0);

    stringptr = pTriangleWrap->findfield(stringptr);
    if (*stringptr == '\0') {
        segmentmarkers = 0;
    }
    else {
        segmentmarkers = (int)strtol(stringptr, &stringptr, 0);
    }

    boundmarker = 0;

    /* Read and insert the segments. */
    for (i = 0; i < /*m->*/insegments; i++)
    {
        stringptr = pTriangleWrap->readline(inputline, polyfile, polyfileName);
        stringptr = pTriangleWrap->findfield(stringptr);
        if (*stringptr == '\0') {
            printf("Error:  Segment %d has no endpoints in %s.\n",
                tpbehavior->firstnumber + i, polyfileName);
            return false; //triexit(1);
        }
        else {
            end1 = (int)strtol(stringptr, &stringptr, 0);
        }
        stringptr = pTriangleWrap->findfield(stringptr);
        if (*stringptr == '\0') {
            printf("Error:  Segment %d is missing its second endpoint in %s.\n",
                tpbehavior->firstnumber + i, polyfileName);
            return false; //triexit(1);
        }
        else {
            end2 = (int)strtol(stringptr, &stringptr, 0);
        }

        if (segmentmarkers) {
            stringptr = pTriangleWrap->findfield(stringptr);
            if (*stringptr == '\0') {
                boundmarker = 0;
            }
            else {
                boundmarker = (int)strtol(stringptr, &stringptr, 0);
            }
        }

        if ((end1 < tpbehavior->firstnumber) ||
            (end1 >= tpbehavior->firstnumber + tpmesh->invertices)) {
            if (!tpbehavior->quiet) {
                printf("Warning:  Invalid first endpoint of segment %d in %s.\n",
                    tpbehavior->firstnumber + i, polyfileName);
            }
        }
        else if ((end2 < tpbehavior->firstnumber) ||
            (end2 >= tpbehavior->firstnumber + tpmesh->invertices)) {
            if (!tpbehavior->quiet) {
                printf("Warning:  Invalid second endpoint of segment %d in %s.\n",
                    tpbehavior->firstnumber + i, polyfileName);
            }
        }
        else {
            // OPEN TODO:::  one last check? ????
#if 0
            /* Find the vertices numbered `end1' and `end2'. */
            endpoint1 = pTriangleWrap->getvertex(m, b, end1);
            endpoint2 = pTriangleWrap->getvertex(m, b, end2);
            if ((endpoint1[0] == endpoint2[0]) && (endpoint1[1] == endpoint2[1])) {
                if (!tpbehavior->quiet) {
                    printf("Warning:  Endpoints of segment %d are coincident in %s.\n",
                        b->firstnumber + i, polyfilename);
                }
            }
            else {
                insertsegment(m, b, endpoint1, endpoint2, boundmarker);
            }
#endif
            m_segmentList.push_back(end1);
            m_segmentList.push_back(end2);
        }
    }

    return true;
}


void Delaunay::SetPoint(Point& point, /*Triwrap::vertex*/ double* vertexptr)
{
   // -- HACK:: double* as not to export internal impl.
   // OPEN TODO: compile test type check - Triwrap::vertex == double* ???

   point[0] = (vertexptr)[0];  // = x
   point[1] = (vertexptr)[1];  // = y
}


int Delaunay::GetFirstIndexNumber() const
{
   Triwrap::__pbehavior* pbehavior = (Triwrap::__pbehavior*)m_pbehavior;
   return pbehavior->firstnumber;
}


#ifdef TRPP_OLD_NAMES_SUPPORTED
int Delaunay::Org(fIterator const& fit, Point* point) const
{
   return fit.Org(point);
}
int Delaunay::Dest(fIterator const& fit, Point* point) const
{
   return fit.Dest(point);
}
int Delaunay::Apex(fIterator const& fit, Point* point) const
{
   return fit.Apex(point);
}
#endif // TRPP_OLD_NAMES_SUPPORTED


typedef Triwrap::vertex   vertex;
typedef Triwrap::triangle triangle;
typedef Triwrap::__otriangle trianglelooptype; // oriented triangle


fIterator Delaunay::locate(int vertexid)
{
   // OPEN:: doesn't seem to be working!
   // OPEN TODO:: move out from Delaunay????

   fIterator retval;
   retval.m_delaunay = this;

   trianglelooptype horiz;               /* Temporary variable for use in locate(). */
   triangle ptr;                         /* Temporary variable used by sym(). */

   TP_MESH_BEHAVIOR_WRAP();

   horiz.tri = tpmesh->dummytri;
   horiz.orient = 0;
   symself(horiz);
   double dv[2];
   dv[0] = m_pointList[vertexid][0];
   dv[1] = m_pointList[vertexid][1];

   /* Search for a triangle containing `newvertex'. */
   int intersect = pTriangleWrap->locate(tpmesh, tpbehavior, dv, &horiz);
   Assert(intersect == Triwrap::ONVERTEX, "Something went wrong in point location\n");

   if (intersect != Triwrap::ONVERTEX)
   {
      // Not on vertex!
      std::cerr << "ERROR: Something went wrong in point location!\n";
      pTriangleWrap->triexit(1);
   }

   retval.floop.tri = horiz.tri;
   retval.floop.orient = horiz.orient;

   return retval;
}


///////////////////////////////
//
//  Face Iterator impl.
//
///////////////////////////////

fIterator::fIterator(Delaunay* triangulator)
   : m_delaunay(triangulator),
     meshPointCount(0)
{
   floop.tri = nullptr;

   Triwrap::__pmesh* tpmesh = (Triwrap::__pmesh*)triangulator->m_pmesh;
   Triwrap* pTriangleWrap = (Triwrap*)triangulator->m_triangleWrap;

   pTriangleWrap->traversalinit(&(tpmesh->triangles));

   trianglelooptype* ploop = (trianglelooptype*)(&floop);
   ploop->tri = pTriangleWrap->triangletraverse(tpmesh);
   ploop->orient = 0;
}


void fIterator::operator++()
{
   // cout << "++ called\n";

   Triwrap::__pmesh* tpmesh = (Triwrap::__pmesh*)m_delaunay->m_pmesh;

   trianglelooptype* ploop = (trianglelooptype*)(&floop);
   Triwrap* pTriangleWrap = (Triwrap*)m_delaunay->m_triangleWrap;

   ploop->tri = pTriangleWrap->triangletraverse(tpmesh);

   // cout << "tri val = " << ploop->tri << endl;
}


bool fIterator::isdummy() const
{
   Triwrap::__pmesh* tpmesh = (Triwrap::__pmesh*)m_delaunay->m_pmesh;

   return (((trianglelooptype*)(&(floop)))->tri == tpmesh->dummytri);
}


bool fIterator::empty() const
{
   return floop.tri == nullptr;
};


int fIterator::Org(Delaunay::Point* point) const
{
   vertex vertexptr = nullptr;
   org(*TP_PLOOP_PTR((*this)), vertexptr);

   if (point) Delaunay::SetPoint(*point, vertexptr);
   return
      getVertexIndex(vertexptr);
}


int fIterator::Dest(Delaunay::Point* point) const
{
   vertex vertexptr = nullptr;
   dest(*TP_PLOOP_PTR((*this)), vertexptr);

   if (point) Delaunay::SetPoint(*point, vertexptr);
   return
      getVertexIndex(vertexptr);
}


int fIterator::Apex(Delaunay::Point* point) const
{
   vertex vertexptr = nullptr;
   apex(*TP_PLOOP_PTR((*this)), vertexptr);

   if (point) Delaunay::SetPoint(*point, vertexptr);
   return
      getVertexIndex(vertexptr);
}


void fIterator::Org(Delaunay::Point& point, int& meshIndex) const
{
   Assert(m_delaunay->m_extraVertexAttr, "");

   vertex vertexptr = nullptr;
   org(*TP_PLOOP_PTR((*this)), vertexptr);

   Delaunay::SetPoint(point, vertexptr);
   meshIndex = getMeshVertexIndex(vertexptr);
}


void fIterator::Dest(Delaunay::Point& point, int& meshIndex) const
{
   Assert(m_delaunay->m_extraVertexAttr, "");

   vertex vertexptr = nullptr;
   dest(*TP_PLOOP_PTR((*this)), vertexptr);

   Delaunay::SetPoint(point, vertexptr);
   meshIndex = getMeshVertexIndex(vertexptr);
}


void fIterator::Apex(Delaunay::Point& point, int& meshIndex) const
{
   Assert(m_delaunay->m_extraVertexAttr, "");

   vertex vertexptr = nullptr;
   apex(*TP_PLOOP_PTR((*this)), vertexptr);

   Delaunay::SetPoint(point, vertexptr);
   meshIndex = getMeshVertexIndex(vertexptr);
}


double fIterator::area() const
{
   // OPEN TODO:: move impl. from Delaunay class!!!

   // ???? really ???? 

   return m_delaunay->area(*this);
}


int fIterator::getVertexIndex(/*Triwrap::vertex*/ double* vertexptr) const
{
   // OPEN TODO: compile test type check - Triwrap::vertex == double* ???

   Triwrap::__pbehavior* tpbehavior = (Triwrap::__pbehavior*)(m_delaunay->m_pbehavior);
   Triwrap::__pmesh* tpmesh = (Triwrap::__pmesh*)(m_delaunay->m_pmesh);

   int ret =
      (((int*)(vertexptr))[tpmesh->vertexmarkindex])
      -
      tpbehavior->firstnumber;

   return ((unsigned)ret < m_delaunay->m_pointList.size()) ? ret : -1;
}


int fIterator::getMeshVertexIndex(/*Triwrap::vertex*/ double* vertexptr) const
{
   if (!m_delaunay->m_extraVertexAttr)
   {
      std::cerr << "ERROR: Mesh indexing not enabled!\n";
      throw std::runtime_error("Mesh indexing not enabled");
   }

   Assert(meshPointCount >= 0, "");

   if (getVertexIndex(vertexptr) >= 0)
   {
      // extra attr. initialized to -1!
      if ((vertexptr)[2] < 0)
      {
         (vertexptr)[2] = meshPointCount++;
      }
   }
   else
   {
      // extra attr. initialized to -1!
      if ((vertexptr)[2] < 0)
      {
         Assert((vertexptr)[2] == -1.00, "");

         (vertexptr)[2] = meshPointCount++;
      }
   }

   int idx = (vertexptr)[2];
   Assert(idx >= 0, "");

   return (vertexptr)[2];
}


bool operator==(fIterator const& fit1, fIterator const& fit2)
{
   return (fit1.floop.tri == fit2.floop.tri);
}


bool operator!=(fIterator const& fit1, fIterator const& fit2)
{
   return !(operator==(fit1, fit2));
}


bool operator<(fIterator const& fit1, fIterator const& fit2)
{
   return (fit1.floop.tri < fit2.floop.tri);
}


///////////////////////////////
//
//  Vertex Iterator impl.
//
///////////////////////////////

vIterator::vIterator(Delaunay* triangulator)
{
   m_delaunay = triangulator;

   Triwrap::__pmesh* tpmesh = (Triwrap::__pmesh*)triangulator->m_pmesh;
   Triwrap::__pbehavior* tpbehavior = (Triwrap::__pbehavior*)triangulator->m_pbehavior;
   Triwrap* pTriangleWrap = (Triwrap*)triangulator->m_triangleWrap;

   pTriangleWrap->traversalinit(&(tpmesh->vertices));
   vloop = pTriangleWrap->vertextraverse(tpmesh);

   while
      (
         tpbehavior->jettison ||
         (
            ((int*)vloop)[tpmesh->vertexmarkindex + 1] == UNDEADVERTEX
            )
         )
   {
      vloop = (void*)pTriangleWrap->vertextraverse(tpmesh);
   }
}


vIterator vIterator::operator++()
{
   Triwrap::__pmesh* tpmesh = (Triwrap::__pmesh*)m_delaunay->m_pmesh;
   Triwrap::__pbehavior* tpbehavior =
      (Triwrap::__pbehavior*)m_delaunay->m_pbehavior;

   Triwrap* pTriangleWrap = (Triwrap*)m_delaunay->m_triangleWrap;

   while
      (
         tpbehavior->jettison ||
         (
            ((int*)vloop)[tpmesh->vertexmarkindex + 1] == UNDEADVERTEX
            )
         )
   {
      vloop = (void*)pTriangleWrap->vertextraverse(tpmesh);
   }

   vloop = (void*)pTriangleWrap->vertextraverse(tpmesh);

   vIterator vit;
   vit.vloop = vloop;
   vit.m_delaunay = m_delaunay;

   return vit;
}


int vIterator::vertexId() const
{
   Triwrap::__pmesh* tpmesh = (Triwrap::__pmesh*)m_delaunay->m_pmesh;
   return ((int*)vloop)[tpmesh->vertexmarkindex];
}


Delaunay::Point& vIterator::operator*() const
{
   return *((Delaunay::Point*)vloop);
}


bool operator==(vIterator const& vit1, vIterator const& vit2)
{
   if (vit1.vloop == vit2.vloop) return true;
   return false;
}


bool operator!=(vIterator const& vit1, vIterator const& vit2)
{
   if (vit1.vloop != vit2.vloop) return true;
   return false;
}


/////////////////////////////////
//
//  Voronoi Point Iterator impl.
//
/////////////////////////////////

vvIterator::vvIterator()
   : m_delaunay(nullptr), vvloop(nullptr), vvindex(0), vvcount(0) 
{
}


vvIterator::vvIterator(Delaunay* triangulator) 
{
   m_delaunay = triangulator;
   triangulateio* pvorout = (struct triangulateio*)triangulator->m_vorout;

   // TEST::: I hope so!
   Assert(triangulator->GetFirstIndexNumber() == 0, "");

   vvloop = pvorout->pointlist;
   vvindex = 0;
   vvcount = pvorout->numberofpoints;
}


vvIterator vvIterator::operator++() 
{
   vvIterator vit;
   vit.vvloop = vvloop;
   vit.vvindex = vvindex;
   vit.m_delaunay = m_delaunay;

   advance(1);
   return vit;
}


Delaunay::Point& vvIterator::operator*() const 
{
   Delaunay::Point::NT* pointlist = (Delaunay::Point::NT*)vvloop;

   // UB! -> but also in original code...  OPEN TODO::: !!!
   return *((Delaunay::Point*)(pointlist + vvindex));
}


void vvIterator::advance(int steps) 
{
   int stepSize = 2;
   Assert(Delaunay::Point().dim() == stepSize, "");

   if (vvindex/stepSize + steps < vvcount) {
      vvindex += steps * stepSize;
   }
   else {
      // at end
      vvindex = 0;
      vvloop = nullptr;
   }

   Assert(vvindex / stepSize < vvcount, "");
}


bool operator==(vvIterator const& lhs, vvIterator const& rhs) 
{
   if (lhs.vvloop == rhs.vvloop && lhs.vvindex == rhs.vvindex) 
      return true;

   return false;
}


bool operator!=(vvIterator const& lhs, vvIterator const& rhs) 
{
   return !(lhs == rhs);
}


/////////////////////////////////
//
//  Voronoi Edge Iterator impl.
//
/////////////////////////////////

veIterator::veIterator()
   : m_delaunay(nullptr), veloop(nullptr), veindex(0), vecount(0) 
{
}


veIterator::veIterator(Delaunay* triangulator) 
{
   m_delaunay = triangulator;
   triangulateio* pvorout = (struct triangulateio*)triangulator->m_vorout;

   // TEST::: I hope so!
   Assert(triangulator->GetFirstIndexNumber() == 0, "");

   veloop = pvorout->edgelist; 
   veindex = 0; 
   vecount = pvorout->numberofedges;
}


veIterator veIterator::operator++() 
{
   veIterator veit;
   veit.veloop = veloop;
   veit.veindex = veindex;
   veit.m_delaunay = m_delaunay;

   // an edge is represented as 2 integer indexes!
   if (veindex / 2 + 1 < vecount ) 
   {
       veindex += 2;
   }
   else 
   {
      veindex = 0;
      veloop = nullptr;
   }

   Assert(veindex / 2 < vecount, "");
   return veit;
}


int veIterator::startPointId() const 
{
   if (!veloop) 
   {
      Assert(false, "");
      return -1;
   }

   auto edgelist = (int*)veloop;
   return edgelist[veindex];
}


int veIterator::endPointId(Delaunay::Point& normvec) const
{
   if (!veloop) 
   {
      Assert(false, "");
      return -1;
   }

   Assert(veindex / 2 < vecount, "");
   auto edgelist = (int*)veloop;
   int idx = edgelist[veindex + 1];
   
   if (idx == -1) 
   {
      triangulateio* pvorout = (struct triangulateio*)m_delaunay->m_vorout;
      auto normlist = pvorout->normlist;
            
      // normlist has same no. of elements as edgelist!
      normvec[0] = normlist[veindex];
      normvec[1] = normlist[veindex + 1];

      Assert(!(normvec[0] == 0.0 && normvec[1] == 0.0), "");
   }
   else 
   {
      normvec[0] = 0.0;
      normvec[1] = 0.0;
   }

   return idx;
}


const Delaunay::Point& veIterator::Org()
{
   // OPEN TODO:: move impl. from Delaunay class!!!
   return m_delaunay->Org(*this);
}


Delaunay::Point veIterator::Dest(bool& finiteEdge)
{
   // OPEN TODO:: move impl. from Delaunay class!!!
   return m_delaunay->Dest(*this, finiteEdge);
}


bool operator==(veIterator const& lhs, veIterator const& rhs) 
{
   if (lhs.veloop == rhs.veloop && lhs.veindex == rhs.veindex) 
      return true;

   return false;
}


bool operator!=(veIterator const& lhs, veIterator const& rhs) 
{
   return !(lhs == rhs);
}


const Delaunay::Point& Delaunay::Org(veIterator const& eit)
{
   auto pointId = eit.startPointId();

   vvIterator vit(this);
   vit.advance(pointId);
   return *vit;
}


Delaunay::Point Delaunay::Dest(veIterator const& eit, bool& finiteEdge)
{
   // OPEN TODO::: optimization --- use const& as return value!

   Point normvec;

   auto pointId = eit.endPointId(normvec);
   finiteEdge = pointId != -1;

   if (pointId == -1) 
   {
      Assert(normvec.sqr_length() != 0.0, "");
      return normvec;
   } 
   else
   {
      Assert(normvec.sqr_length() == 0.0, "");
      
      vvIterator vit(this);
      vit.advance(pointId);
      return *vit;
   }
}


/////////////////////////////////
//
//  TriangulationMesh impl.
//
/////////////////////////////////

TriangulationMesh::TriangulationMesh(Delaunay* triangulator)
   : m_delaunay(triangulator)
{
}


int TriangulationMesh::Sym(fIterator const& fit, char i) const
{
   TP_MESH_PLOOP(fit);

   char oval = (char)ploop->orient;
   ploop->orient = i;

   trianglelooptype top;
   triangle ptr;  // Temporary variable used by sym() macro! 
   sym(*ploop, top);
   ploop->orient = oval;

   if (top.tri != tpmesh->dummytri)
   {
      vertex farvertex;
      apex(top, farvertex);
      return ((int*)farvertex)[tpmesh->vertexmarkindex];
   }

   return -1;
}


fIterator TriangulationMesh::Sym(fIterator const& fit) const
{
   fIterator retval;
   retval.m_delaunay = fit.m_delaunay;

   TP_MESH_PLOOP(fit);

   trianglelooptype top;
   triangle ptr;  // Temporary variable used by sym() macro! 
   sym(*ploop, top);

   if (top.tri != tpmesh->dummytri)
   {
      retval.floop.tri = top.tri;
      retval.floop.orient = top.orient;
      return retval;
   }

   retval.floop.tri = nullptr;
   retval.floop.orient = 0;
   return retval;
}


fIterator TriangulationMesh::locate(int vertexid)
{
   // OPEN TODO:: move impl from Delaunay???
   return m_delaunay->locate(vertexid);

# if 0
   fIterator retval;
   retval.m_delaunay = m_delaunay;

   trianglelooptype horiz;               /* Temporary variable for use in locate(). */
   triangle ptr;                         /* Temporary variable used by sym(). */

   TP_MESH_BEHAVIOR_WRAP();

   horiz.tri = tpmesh->dummytri;
   horiz.orient = 0;
   symself(horiz);
   double dv[2];
   dv[0] = m_pointList[vertexid][0];
   dv[1] = m_pointList[vertexid][1];

   /* Search for a triangle containing `newvertex'. */
   int intersect = pTriangleWrap->locate(tpmesh, tpbehavior, dv, &horiz);
   Assert(intersect != Triwrap::ONVERTEX, "Something went wrong in point location\n");

   if (intersect != Triwrap::ONVERTEX)
   {
      // Not on vertex!
      std::cerr << "ERROR: Something went wrong in point location!\n";
      pTriangleWrap->triexit(1);
   }

   retval.floop.tri = horiz.tri;
   retval.floop.orient = horiz.orient;

   return retval;
#endif
}


fIterator TriangulationMesh::Lnext(fIterator const& fit)
{
   fIterator retval;
   retval.m_delaunay = m_delaunay;

   lnext((*(trianglelooptype*)(&(fit.floop))), (*(trianglelooptype*)(&(retval.floop))));
   return retval;
}


fIterator TriangulationMesh::Lprev(fIterator const& fit)
{
   fIterator retval;
   retval.m_delaunay = m_delaunay;

   lprev((*(trianglelooptype*)(&(fit.floop))), (*(trianglelooptype*)(&(retval.floop))));
   return retval;
}


fIterator TriangulationMesh::Onext(fIterator const& fit)
{
   triangle ptr;
   fIterator retval;
   retval.m_delaunay = m_delaunay;

   //cout << "Onext called:\n " 
   //	 << Org(fit) << "\t" << Dest(fit) << "\t" << Apex(fit) << "\n";

   onext((*(trianglelooptype*)(&(fit.floop))), (*(trianglelooptype*)(&(retval.floop))));

   // retval could be dummy!
   return retval;
}


fIterator TriangulationMesh::Oprev(fIterator const& fit)
{
   triangle ptr;
   fIterator retval;
   retval.m_delaunay = m_delaunay;

   oprev((*(trianglelooptype*)(&(fit.floop))), (*(trianglelooptype*)(&(retval.floop))));
   return retval;
}


void TriangulationMesh::trianglesAroundVertex(int vertexid, std::vector<int>& ivv)
{
   fIterator fit = locate(vertexid);
   ivv.clear();

   int start = fit.Dest();
   int linkn = fit.Apex();

   ivv.push_back(vertexid);
   ivv.push_back(start);
   ivv.push_back(linkn);

   fIterator nfit = fit;
   fIterator pnfit = fit; // follows nfit by one triangle

   while (linkn != start)
   {
      nfit = Onext(nfit);
      if (nfit.isdummy())
      {
         // Do another algorithm
         ivv.clear();

         // use oprev now...
         fit = pnfit;
         nfit = fit;

         start = fit.Apex();
         linkn = fit.Dest();

         ivv.push_back(vertexid);
         ivv.push_back(linkn);
         ivv.push_back(start);

         while (linkn != start)
         {
            nfit = Oprev(nfit);
            if (nfit.isdummy())
               return;
            int a = nfit.Org();
            int b = nfit.Dest();
            int c = nfit.Apex();
            ivv.push_back(a);
            ivv.push_back(b);
            ivv.push_back(c);
            linkn = nfit.Dest();
         }

         return;
      }

      pnfit = nfit;

      int a = nfit.Org();
      int b = nfit.Dest();
      int c = nfit.Apex();

      //cout << "Triangle: " << a << "\t"  << b << "\t"  << c << "\n";

      ivv.push_back(a);
      ivv.push_back(b);
      ivv.push_back(c);

      linkn = nfit.Apex();
   }
}


} // namespace tpp
